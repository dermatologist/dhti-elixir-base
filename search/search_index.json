{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DHTI ELIXIR BASE","text":"<p>Base library for creating new DHTI Elixirs.</p> <p>What is DHTI? DHTI (Digital Health Tooling Interface) provides building blocks for interoperable, healthcare-focused AI tooling. This repository is the minimal foundation you extend to build your own \"Elixir\"\u2014a reusable, testable component (chain/agent/server) that plugs into the wider DHTI ecosystem.</p> <p>Status: WIP, but stable enough to scaffold new Elixirs and iterate quickly.</p> <p></p>"},{"location":"#overview","title":"Overview","text":"<p>This package exposes lightweight, composable base classes:</p> <ul> <li><code>BaseChain</code> \u2013 a LangChain-compatible chain scaffold with sensible defaults.</li> <li><code>BaseAgent</code> \u2013 an agent scaffold that can bind tools and work with LangGraph.</li> <li><code>BaseGraph</code>, <code>BaseLLM</code>, <code>BaseServer</code>, <code>BaseSpace</code>, and <code>BaseDhtiModel</code> \u2013 helpers to organize more complex Elixirs.</li> </ul> <p>Use these to rapidly create a new Elixir with a consistent structure, tests, and docs.</p>"},{"location":"#dependency-injection-mydipy-di","title":"Dependency Injection (mydi.py / di)","text":"<p>The codebase uses a simple dependency injection pattern via <code>mydi.py</code> and the <code>get_di</code> function. This allows you to: - Configure FHIR endpoints, authentication, and other settings at runtime - Swap out implementations for testing or customization - Keep your code modular and maintainable</p>"},{"location":"#cds-hook-module-frontend-integration","title":"CDS Hook Module (Frontend Integration)","text":"<p>The <code>cds_hook</code> module now provides  request parsing and context extraction for CDS Hooks workflows. It supports: - Parsing various CDS Hooks request formats - Extracting patient and order context</p> <p>This enables integration with frontend CDS Hooks clients.</p>"},{"location":"#fhir-module-backend-integration-smart-on-fhir-fhirpath","title":"FHIR Module (Backend Integration: SMART on FHIR &amp; FHIRPath)","text":"<p>The <code>fhir</code> module  includes advanced backend features: - SMART on FHIR: The <code>SmartOnFhirSearch</code> class provides secure, standards-based access to FHIR resources using OAuth2 and the SMART on FHIR protocol. It supports:     - Patient-centric resource queries (Conditions, Observations, Procedures, MedicationRequests, AllergyIntolerances)     - $everything operation for comprehensive patient data     - Automatic token management and authentication - FHIRPath Support: All resource queries can apply FHIRPath expressions for flexible data extraction and transformation.</p> <p></p>"},{"location":"#project-layout","title":"Project layout","text":"<ul> <li><code>src/dhti_elixir_base/</code> \u2013 base classes and minimal utilities.</li> <li><code>tests/</code> \u2013 example tests to keep your Elixir robust.</li> <li><code>examples/</code> \u2013 quick patterns for chains/graphs.</li> <li><code>docs/</code> \u2013 MkDocs configuration for documentation.</li> </ul>"},{"location":"#learn-more","title":"Learn more","text":"<ul> <li>DHTI home: https://github.com/dermatologist/dhti</li> <li>This template docs: https://dermatologist.github.io/dhti-elixir-base/</li> </ul>"},{"location":"#give-us-a-star","title":"Give us a star \u2b50\ufe0f","text":"<p>If you find this project useful, give us a star. It helps others discover the project.</p>"},{"location":"#contributors","title":"Contributors","text":"<ul> <li>Bell Eapen | </li> </ul>"},{"location":"contributing/","title":"# Contributing to <code>dhti-elixir-base</code>","text":""},{"location":"contributing/#please-note","title":"Please note:","text":"<ul> <li>(Optional) We adopt Git Flow. Most feature branches are pushed to the repository and deleted when merged to develop branch.</li> <li>(Important): Submit pull requests to the develop branch or feature/ branches</li> <li>Use GitHub Issues for feature requests and bug reports. Include as much information as possible while reporting bugs.</li> </ul>"},{"location":"contributing/#contributing-step-by-step","title":"Contributing (Step-by-step)","text":"<ol> <li> <p>Fork the repo and clone it to your local computer, and set up the upstream remote:</p> <pre><code>git clone https://github.com/YourGitHubHandle/dhti-elixir-base.git\ncd dhti-elixir-base\ngit remote add upstream https://github.com/dermatologist/dhti-elixir-base.git\n</code></pre> </li> <li> <p>Checkout out a new local branch based on your master and update it to the latest (BRANCH-123 is the branch name, You can name it whatever you want. Try to give it a meaningful name. If you are fixing an issue, please include the issue #).</p> <pre><code>git checkout -b BRANCH-123 develop\ngit clean -df\ngit pull --rebase upstream develop\n</code></pre> </li> </ol> <p>Please keep your code clean. If you find another bug, you want to fix while being in a new branch, please fix it in a separated branch instead.</p> <ol> <li> <p>Push the branch to your fork. Treat it as a backup.</p> <pre><code>git push origin BRANCH-123\n</code></pre> </li> <li> <p>Code</p> </li> <li> <p>Adhere to common conventions you see in the existing code.</p> </li> <li> <p>Include tests as much as possible, and ensure they pass.</p> </li> <li> <p>Commit to your branch</p> <pre><code> git commit -m \"BRANCH-123: Put change summary here (can be a ticket title)\"\n</code></pre> </li> </ol> <p>NEVER leave the commit message blank! Provide a detailed, clear, and complete description of your commit!</p> <ol> <li> <p>Update your branch to the latest code.</p> <pre><code>git pull --rebase upstream develop\n</code></pre> </li> <li> <p>Important If you have made many commits, please squash them into atomic units of work. (Most Git GUIs such as sourcetree and smartgit offer a squash option)</p> <pre><code>git checkout develop\ngit pull --rebase upstream develop\ngit merge --squash BRANCH-123\ngit commit -m \"fix: 123\"\n</code></pre> </li> </ol> <p>Push changes to your fork:</p> <pre><code>    git push\n</code></pre> <ol> <li>Issue a Pull Request</li> </ol> <p>In order to make a pull request:   * Click \"Pull Request\".   * Choose the develop branch   * Click 'Create pull request'   * Fill in some details about your potential patch including a meaningful title.   * Click \"Create pull request\".</p> <p>Thanks for that -- we'll get to your pull request ASAP. We love pull requests!</p>"},{"location":"contributing/#feedback","title":"Feedback","text":"<p>If you need to contact me, see my contact details on my profile page.</p>"},{"location":"github-dependents-info/","title":"Dependents stats for dermatologist/dhti-elixir-base","text":""},{"location":"github-dependents-info/#package-dermatologistdhti-elixir-base","title":"Package dermatologist/dhti-elixir-base","text":"Repository Stars dermatologist / dhti 10 dermatologist / dhti-elixir-template 1 <p>Generated using github-dependents-info, by Nicolas Vuillamy</p>"},{"location":"modules/","title":"Modules","text":"<p>Copyright 2023 Bell Eapen</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p> <p>Copyright 2025 Bell Eapen</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>https://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p> <p>Copyright 2024 Bell Eapen</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>https://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p> <p>Pydantic Model for CDS Hook Card</p> <p>Example:</p> <p>{   \"summary\": \"Patient is at high risk for opioid overdose.\",   \"detail\": \"According to CDC guidelines, the patient's opioid dosage should be tapered to less than 50 MME. Link to CDC Guideline\",   \"indicator\": \"warning\",   \"source\": {     \"label\": \"CDC Opioid Prescribing Guidelines\",     \"url\": \"https://www.cdc.gov/drugoverdose/prescribing/guidelines.html\",     \"icon\": \"https://example.org/img/cdc-icon.png\"   },   \"links\": [     {       \"label\": \"View MME Conversion Table\",       \"url\": \"https://www.cdc.gov/drugoverdose/prescribing/mme.html\"     }   ] }</p> <p>Copyright 2025 Bell Eapen</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>https://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p> <p>Copyright 2025 Bell Eapen</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>https://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p> <p>CDS Hook Request Model</p> <p>Pydantic Model for CDS Hook Request. Typically context has \"patientId\" and \"input\" keys.</p> <p>Example: {   \"hookInstance\": \"d1577c69-dfbe-44ad-ba6d-3e05e953b2ea\",   \"fhirServer\": \"https://example.com/fhir\",   \"fhirAuthorization\": { ... },   \"hook\": \"patient-view\",   \"context\": { ... },   \"prefetch\": { ... } }</p> <p>Pydantic models for CDS Hook Service</p> <p>Example: {   \"services\": [     {       \"hook\": \"patient-view\",       \"name\": \"Static CDS Service Example\",       \"description\": \"An example of a CDS Service that returns a card with SMART app recommendations.\",       \"id\": \"static-patient-view\",       \"prefetch\": {         \"patientToGreet\": \"Patient/{{context.patientId}}\"       }     }   ] }</p>"},{"location":"modules/#agent.BaseAgent","title":"<code>BaseAgent</code>","text":"Source code in <code>src/dhti_elixir_base/agent.py</code> <pre><code>class BaseAgent:\n\n    class AgentInput(BaseModel):\n        \"\"\"Chat history with the bot.\"\"\"\n        input: str\n        model_config = ConfigDict(extra=\"ignore\", arbitrary_types_allowed=True)\n\n    def __init__(\n        self,\n        name=None,\n        description=None,\n        llm=None,\n        prompt=None,\n        input_type: type[BaseModel] | None = None,\n        tools: list | None = None,\n        mcp={\n            \"mcpx\": {\n                \"transport\": \"http\",\n                \"url\": \"http://mcpx:9000/mcp\",\n            }\n        },\n    ):\n        self.llm = llm or get_di(\"function_llm\")\n        self.prompt = prompt or get_di(\"agent_prompt\") or \"You are a helpful assistant.\"\n        self.tools = tools if tools is not None else []\n        self._name = name or camel_to_snake(self.__class__.__name__)\n        self._description = description or f\"Agent for {self._name}\"\n        if input_type is None:\n            self.input_type = self.AgentInput\n        else:\n            self.input_type = input_type\n        self.client = MultiServerMCPClient(mcp)\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def description(self):\n        return self._description\n\n    @name.setter\n    def name(self, value):\n        self._name = value\n\n    @description.setter\n    def description(self, value):\n        self._description = value\n\n    def has_tool(self) -&gt; bool:\n        \"\"\"Check if the agent has any tools.\"\"\"\n        try:\n            _tools = asyncio.run(self.client.get_tools())\n            return bool(_tools)\n        except Exception as e:\n            logger.error(f\"Error checking tools: {e}\")\n            return False\n\n    def get_agent_response(self, context: str) -&gt; str:\n        if self.llm is None:\n            raise ValueError(\"llm must not be None when initializing the agent.\")\n        result = \"Agent encountered an error while processing your request.\"\n        try:\n            # if self.tools is an empty list, load tools from MCP\n            if not self.tools:\n                _tools = asyncio.run(self.client.get_tools())\n            else:\n                _tools = self.tools\n            _agent = create_agent(model=self.llm, tools=_tools, system_prompt=self.prompt)\n\n            result = asyncio.run(_agent.ainvoke(\n                {\"messages\": [{\"role\": \"user\", \"content\": context}]}\n            ))\n            ai_message = result[\"messages\"][-1].content\n            return str(ai_message)\n        except Exception as e:\n            logger.error(f\"Error in agent processing: {e}\")\n            return str(result)\n\n    async def get_langgraph_mcp_agent(self):\n        \"\"\"Get the agent executor for async execution.\"\"\"\n        if self.llm is None:\n            raise ValueError(\"llm must not be None when initializing the agent executor.\")\n        if self.client is None:\n            raise ValueError(\"MCP client must not be None when initializing the agent.\")\n        tools = await self.get_langgraph_mcp_tools()\n        agent = create_agent(\n            model=self.llm,\n            tools=tools,\n            system_prompt=self.prompt,\n        )\n        return agent\n\n    async def get_langgraph_mcp_tools(self, session_name=\"dhti\"):\n        \"\"\"Get the agent executor for async execution with session.\"\"\"\n        if self.client is None:\n            raise ValueError(\"MCP client must not be None when initializing the agent.\")\n        async with self.client.session(session_name) as session:\n            tools = await load_mcp_tools(session)\n        return tools\n</code></pre>"},{"location":"modules/#agent.BaseAgent.AgentInput","title":"<code>AgentInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Chat history with the bot.</p> Source code in <code>src/dhti_elixir_base/agent.py</code> <pre><code>class AgentInput(BaseModel):\n    \"\"\"Chat history with the bot.\"\"\"\n    input: str\n    model_config = ConfigDict(extra=\"ignore\", arbitrary_types_allowed=True)\n</code></pre>"},{"location":"modules/#agent.BaseAgent.get_langgraph_mcp_agent","title":"<code>get_langgraph_mcp_agent()</code>  <code>async</code>","text":"<p>Get the agent executor for async execution.</p> Source code in <code>src/dhti_elixir_base/agent.py</code> <pre><code>async def get_langgraph_mcp_agent(self):\n    \"\"\"Get the agent executor for async execution.\"\"\"\n    if self.llm is None:\n        raise ValueError(\"llm must not be None when initializing the agent executor.\")\n    if self.client is None:\n        raise ValueError(\"MCP client must not be None when initializing the agent.\")\n    tools = await self.get_langgraph_mcp_tools()\n    agent = create_agent(\n        model=self.llm,\n        tools=tools,\n        system_prompt=self.prompt,\n    )\n    return agent\n</code></pre>"},{"location":"modules/#agent.BaseAgent.get_langgraph_mcp_tools","title":"<code>get_langgraph_mcp_tools(session_name='dhti')</code>  <code>async</code>","text":"<p>Get the agent executor for async execution with session.</p> Source code in <code>src/dhti_elixir_base/agent.py</code> <pre><code>async def get_langgraph_mcp_tools(self, session_name=\"dhti\"):\n    \"\"\"Get the agent executor for async execution with session.\"\"\"\n    if self.client is None:\n        raise ValueError(\"MCP client must not be None when initializing the agent.\")\n    async with self.client.session(session_name) as session:\n        tools = await load_mcp_tools(session)\n    return tools\n</code></pre>"},{"location":"modules/#agent.BaseAgent.has_tool","title":"<code>has_tool()</code>","text":"<p>Check if the agent has any tools.</p> Source code in <code>src/dhti_elixir_base/agent.py</code> <pre><code>def has_tool(self) -&gt; bool:\n    \"\"\"Check if the agent has any tools.\"\"\"\n    try:\n        _tools = asyncio.run(self.client.get_tools())\n        return bool(_tools)\n    except Exception as e:\n        logger.error(f\"Error checking tools: {e}\")\n        return False\n</code></pre>"},{"location":"modules/#chain.BaseChain","title":"<code>BaseChain</code>","text":"Source code in <code>src/dhti_elixir_base/chain.py</code> <pre><code>@inject\nclass BaseChain:\n\n    class ChainInput(BaseModel):\n        \"\"\"\n        Input model for BaseChain.\n\n        Attributes:\n            input (Any): The input string or CDSHookRequest object for the chain.\n        \"\"\"\n\n        input: Any\n        model_config = ConfigDict(extra=\"ignore\", arbitrary_types_allowed=True)\n\n    def __init__(\n        self,\n        prompt=None,\n        name=None,\n        description=None,\n        main_llm=None,\n        clinical_llm=None,\n        grounding_llm=None,\n        input_type=None,\n        output_type=None,\n    ):\n        self._prompt = prompt or get_di(\"main_prompt\")\n        self._main_llm = main_llm or get_di(\"base_main_llm\")\n        self._clinical_llm = clinical_llm or get_di(\"base_clinical_llm\")\n        self._grounding_llm = grounding_llm or get_di(\"base_grounding_llm\")\n        self._input_type = input_type or self.ChainInput\n        self._output_type = output_type\n        self._name = name\n        self._description = description\n        self.init_prompt()\n\n    @property\n    def chain(self):\n        \"\"\"Get the runnable chain.\n\n        Example usage of an agent in the chain:\n        BaseAgent takes llm, prompt, tools as input. If tools is not provided, it loads tools from MCP. default llm is function_llm from DI.\n        Default prompt is \"You are a helpful assistant.\"\n        self.my_agent = BaseAgent().get_agent_response # in __init__\n        _chain = (\n            RunnablePassthrough()\n            | get_string_message_to_agent\n            | self.my_agent\n            | StrOutputParser()\n        )\n\n        RunnableParallel / RunnablePassthrough / RunnableSequential / RunnableLambda / RunnableMap / RunnableBranch\n        \"\"\"\n        if self.prompt is None:\n            raise ValueError(\"Prompt must not be None when building the chain.\")\n        _sequential = (\n            RunnablePassthrough()\n            | get_context  # function to extract context from input # type: ignore\n            | self.prompt  # \"{input}\"\"\n            | self.main_llm\n            | StrOutputParser()\n            | add_card  # function to wrap output in CDSHookCard\n        )\n        chain = _sequential.with_types(input_type=self.input_type)\n        return chain\n\n    @property\n    def prompt(self):\n        return self._prompt\n\n    @property\n    def main_llm(self):\n        if self._main_llm is None:\n            self._main_llm = get_di(\"base_main_llm\")\n        return self._main_llm\n\n    @property\n    def clinical_llm(self):\n        if self._clinical_llm is None:\n            self._clinical_llm = get_di(\"base_clinical_llm\")\n        return self._clinical_llm\n\n    @property\n    def grounding_llm(self):\n        if self._grounding_llm is None:\n            self._grounding_llm = get_di(\"base_grounding_llm\")\n        return self._grounding_llm\n\n    @property\n    def input_type(self):\n        if self._input_type is None:\n            self._input_type = self.ChainInput\n        return self._input_type\n\n    @property\n    def output_type(self):\n        return self._output_type\n\n    @property\n    def name(self):\n        if self._name is None:\n            return camel_to_snake(self.__class__.__name__)\n\n    @property\n    def description(self):\n        if self._description is None:\n            self._description = f\"Chain for {self.name}\"\n        return self._description\n\n    @prompt.setter\n    def prompt(self, value):\n        self._prompt = value\n        self.init_prompt()\n\n    @main_llm.setter\n    def main_llm(self, value):\n        self._main_llm = value\n\n    @clinical_llm.setter\n    def clinical_llm(self, value):\n        self._clinical_llm = value\n\n    @grounding_llm.setter\n    def grounding_llm(self, value):\n        self._grounding_llm = value\n\n    @input_type.setter\n    def input_type(self, value):\n        self._input_type = value\n\n    @output_type.setter\n    def output_type(self, value):\n        self._output_type = value\n\n    @name.setter\n    def name(self, value):\n        self._name = value\n\n    @description.setter\n    def description(self, value):\n        self._description = value\n\n    def invoke(self, **kwargs):\n        if self.chain is None:\n            raise ValueError(\"Chain is not initialized.\")\n        return self.chain.invoke(kwargs)\n\n    def __call__(self, **kwargs):\n        return self.invoke(**kwargs)\n\n    @DeprecationWarning\n    def get_runnable(self, **kwargs):\n        return self.chain\n\n    # * Override these methods in subclasses\n    def init_prompt(self):\n        pass\n\n    def generate_llm_config(self):\n        \"\"\"\n        Generate the configuration schema for the LLM function call.\n\n        Returns:\n            dict: A dictionary containing the function schema for the LLM, including name, description, and parameters.\n        \"\"\"\n        # Use Pydantic v2 API; `schema()` is deprecated in favor of `model_json_schema()`\n        _input_schema = self.input_type.model_json_schema()\n        function_schema = {\n            \"name\": (self.name or self.__class__.__name__).lower().replace(\" \", \"_\"),\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": _input_schema.get(\"type\", \"object\"),\n                \"properties\": _input_schema.get(\"properties\", {}),\n                \"required\": _input_schema.get(\"required\", []),\n            },\n        }\n        return function_schema\n\n    def get_chain_as_langchain_tool(self):\n        \"\"\"\n        Convert the chain to a LangChain StructuredTool.\n\n        Returns:\n            StructuredTool: An instance of LangChain StructuredTool wrapping the chain.\n        \"\"\"\n\n        def _run(**kwargs):\n            # Invoke the underlying runnable chain with provided kwargs\n            return self.chain.invoke(kwargs)  # type: ignore\n\n        return StructuredTool.from_function(\n            func=_run,\n            name=self.name or self.__class__.__name__,\n            description=self.description or f\"Chain for {self.name}\",\n            args_schema=self.input_type,\n        )\n\n    def get_chain_as_mcp_tool(self):\n        \"\"\"\n        Convert the chain to an MCP tool using the FastMCP adapter.\n\n        Returns:\n            Any: An MCP tool instance wrapping the chain.\n        \"\"\"\n        _fast_mcp = to_fastmcp(\n            self.get_chain_as_langchain_tool(),\n        )\n        _fast_mcp.title = self.name or self.__class__.__name__\n        return _fast_mcp\n\n    def print_log(self, message):\n        logger.info(message)\n        return message\n</code></pre>"},{"location":"modules/#chain.BaseChain.chain","title":"<code>chain</code>  <code>property</code>","text":"<p>Get the runnable chain.</p> <p>Example usage of an agent in the chain: BaseAgent takes llm, prompt, tools as input. If tools is not provided, it loads tools from MCP. default llm is function_llm from DI. Default prompt is \"You are a helpful assistant.\" self.my_agent = BaseAgent().get_agent_response # in init _chain = (     RunnablePassthrough()     | get_string_message_to_agent     | self.my_agent     | StrOutputParser() )</p> <p>RunnableParallel / RunnablePassthrough / RunnableSequential / RunnableLambda / RunnableMap / RunnableBranch</p>"},{"location":"modules/#chain.BaseChain.ChainInput","title":"<code>ChainInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input model for BaseChain.</p> <p>Attributes:</p> Name Type Description <code>input</code> <code>Any</code> <p>The input string or CDSHookRequest object for the chain.</p> Source code in <code>src/dhti_elixir_base/chain.py</code> <pre><code>class ChainInput(BaseModel):\n    \"\"\"\n    Input model for BaseChain.\n\n    Attributes:\n        input (Any): The input string or CDSHookRequest object for the chain.\n    \"\"\"\n\n    input: Any\n    model_config = ConfigDict(extra=\"ignore\", arbitrary_types_allowed=True)\n</code></pre>"},{"location":"modules/#chain.BaseChain.generate_llm_config","title":"<code>generate_llm_config()</code>","text":"<p>Generate the configuration schema for the LLM function call.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the function schema for the LLM, including name, description, and parameters.</p> Source code in <code>src/dhti_elixir_base/chain.py</code> <pre><code>def generate_llm_config(self):\n    \"\"\"\n    Generate the configuration schema for the LLM function call.\n\n    Returns:\n        dict: A dictionary containing the function schema for the LLM, including name, description, and parameters.\n    \"\"\"\n    # Use Pydantic v2 API; `schema()` is deprecated in favor of `model_json_schema()`\n    _input_schema = self.input_type.model_json_schema()\n    function_schema = {\n        \"name\": (self.name or self.__class__.__name__).lower().replace(\" \", \"_\"),\n        \"description\": self.description,\n        \"parameters\": {\n            \"type\": _input_schema.get(\"type\", \"object\"),\n            \"properties\": _input_schema.get(\"properties\", {}),\n            \"required\": _input_schema.get(\"required\", []),\n        },\n    }\n    return function_schema\n</code></pre>"},{"location":"modules/#chain.BaseChain.get_chain_as_langchain_tool","title":"<code>get_chain_as_langchain_tool()</code>","text":"<p>Convert the chain to a LangChain StructuredTool.</p> <p>Returns:</p> Name Type Description <code>StructuredTool</code> <p>An instance of LangChain StructuredTool wrapping the chain.</p> Source code in <code>src/dhti_elixir_base/chain.py</code> <pre><code>def get_chain_as_langchain_tool(self):\n    \"\"\"\n    Convert the chain to a LangChain StructuredTool.\n\n    Returns:\n        StructuredTool: An instance of LangChain StructuredTool wrapping the chain.\n    \"\"\"\n\n    def _run(**kwargs):\n        # Invoke the underlying runnable chain with provided kwargs\n        return self.chain.invoke(kwargs)  # type: ignore\n\n    return StructuredTool.from_function(\n        func=_run,\n        name=self.name or self.__class__.__name__,\n        description=self.description or f\"Chain for {self.name}\",\n        args_schema=self.input_type,\n    )\n</code></pre>"},{"location":"modules/#chain.BaseChain.get_chain_as_mcp_tool","title":"<code>get_chain_as_mcp_tool()</code>","text":"<p>Convert the chain to an MCP tool using the FastMCP adapter.</p> <p>Returns:</p> Name Type Description <code>Any</code> <p>An MCP tool instance wrapping the chain.</p> Source code in <code>src/dhti_elixir_base/chain.py</code> <pre><code>def get_chain_as_mcp_tool(self):\n    \"\"\"\n    Convert the chain to an MCP tool using the FastMCP adapter.\n\n    Returns:\n        Any: An MCP tool instance wrapping the chain.\n    \"\"\"\n    _fast_mcp = to_fastmcp(\n        self.get_chain_as_langchain_tool(),\n    )\n    _fast_mcp.title = self.name or self.__class__.__name__\n    return _fast_mcp\n</code></pre>"},{"location":"modules/#llm.BaseLLM","title":"<code>BaseLLM</code>","text":"<p>               Bases: <code>LLM</code></p> Source code in <code>src/dhti_elixir_base/llm.py</code> <pre><code>class BaseLLM(LLM):\n\n    base_url: str | None = Field(\n        None, alias=\"base_url\"\n    )  #! Alias is important when inheriting from LLM\n    model: str | None = Field(None, alias=\"model\")\n    api_key: str | None = Field(None, alias=\"api_key\")\n    params: Mapping[str, Any] = Field(default_factory=dict, alias=\"params\")\n    timeout: int = 60\n    backend: str | None = \"dhti\"\n    temperature: float | None = 0.1\n    top_p: float | None = 0.8\n    top_k: int | None = 40\n    n_batch: int | None = 8\n    n_threads: int | None = 4\n    n_predict: int | None = 256\n    max_output_tokens: int | None = 512\n    repeat_last_n: int | None = 64\n    repeat_penalty: float | None = 1.18\n\n    def __init__(self, base_url: str, model: str, **kwargs):\n        super().__init__(**kwargs)\n        self.base_url = base_url\n        self.model = model\n        self.params = {**self._get_model_default_parameters, **kwargs}\n\n    @property\n    def _get_model_default_parameters(self):\n        return {\n            \"max_output_tokens\": self.max_output_tokens,\n            \"n_predict\": self.n_predict,\n            \"top_k\": self.top_k,\n            \"top_p\": self.top_p,\n            \"temperature\": self.temperature,\n            \"n_batch\": self.n_batch,\n            \"repeat_penalty\": self.repeat_penalty,\n            \"repeat_last_n\": self.repeat_last_n,\n        }\n\n    @property\n    def _identifying_params(self) -&gt; Mapping[str, Any]:\n        \"\"\"\n        Get all the identifying parameters\n        \"\"\"\n        return {\n            \"model\": self.model,\n            \"base_url\": self.base_url,\n            \"model_parameters\": self._get_model_default_parameters,\n        }\n\n    @property\n    def _llm_type(self) -&gt; str:\n        return \"dhti\"\n\n    def _prepare_payload(self, prompt: str) -&gt; dict:\n        # Basic chat messages wrapper; user prompt placed as single user message\n        return {\n            \"model\": self.model,\n            \"options\": self._get_model_default_parameters,\n            \"messages\": [{\"role\": \"user\", \"content\": prompt}],\n        }\n\n    def _call(\n        self,\n        prompt: str,\n        stop: list[str] | None = None,\n        run_manager: Any | None = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"\n        Args:\n            prompt: The prompt to pass into the model.\n            stop: A list of strings to stop generation when encountered\n            run_manager: Optional run manager for callbacks and tracing\n\n        Returns:\n            The string generated by the model\n        \"\"\"\n\n        payload = self._prepare_payload(prompt)\n        headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": f\"Bearer {self.api_key}\",\n        }\n        resp = requests.post(\n            self.base_url, headers=headers, json=payload, timeout=self.timeout  # type: ignore\n        )\n        try:\n            resp.raise_for_status()\n        except Exception as e:\n            raise RuntimeError(\n                f\"API request failed: {e}; status={resp.status_code}; body={resp.text}\"\n            )\n\n        data = resp.json()\n        # Expecting structure like: { \"choices\": [ { \"message\": { \"role\":\"assistant\",\"content\":\"...\" } } ] }\n        # Adapt this path if the API differs\n        if \"choices\" in data and len(data[\"choices\"]) &gt; 0:\n            choice = data[\"choices\"][0]\n            # support both \"message\" and direct \"text\"\n            text = None\n            if (\n                isinstance(choice, dict)\n                and \"message\" in choice\n                and isinstance(choice[\"message\"], dict)\n            ):\n                text = choice[\"message\"].get(\"content\")\n            elif \"text\" in choice:\n                text = choice.get(\"text\")\n            if text is not None:\n                return text\n        # Fallback: return raw JSON string for debugging\n        return json.dumps(data)\n</code></pre>"},{"location":"modules/#mcp.BaseMCPServer","title":"<code>BaseMCPServer</code>","text":"<p>               Bases: <code>FastMCP</code></p> <p>Base class for MCP servers, extending FastMCP for custom functionality.</p> Source code in <code>src/dhti_elixir_base/mcp.py</code> <pre><code>class BaseMCPServer(FastMCP):\n    \"\"\"Base class for MCP servers, extending FastMCP for custom functionality.\"\"\"\n\n    def __init__(self, name: str | None = None):\n        self._name = name or \"BaseMCPServer\"\n        super().__init__(name=self._name)\n\n    @property\n    def name(self):\n        \"\"\"Return the name of this MCP server instance.\"\"\"\n        return self._name\n</code></pre>"},{"location":"modules/#mcp.BaseMCPServer.name","title":"<code>name</code>  <code>property</code>","text":"<p>Return the name of this MCP server instance.</p>"},{"location":"modules/#model.BaseDhtiModel","title":"<code>BaseDhtiModel</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A model class to lead the model and tokenizer</p> Source code in <code>src/dhti_elixir_base/model.py</code> <pre><code>class BaseDhtiModel(ABC):\n    \"\"\"A model class to lead the model and tokenizer\"\"\"\n\n    model: Any = None\n\n    def __init__(\n        self,\n        model: Any,\n    ) -&gt; None:\n        self.model = model\n\n    @classmethod\n    @abstractmethod\n    def load(cls) -&gt; None:\n        if cls.model is None:\n            log.info(\"Loading model\")\n            t0 = perf_counter()\n            # Load the model here\n            elapsed = 1000 * (perf_counter() - t0)\n            log.info(\"Model warm-up time: %d ms.\", elapsed)\n        else:\n            log.info(\"Model is already loaded\")\n\n    @classmethod\n    @abstractmethod\n    def predict(cls, input: Any, **kwargs) -&gt; Any:\n        assert input is not None and cls.model is not None  # Sanity check\n\n        # Make sure the model is loaded.\n        cls.load()\n        t0 = perf_counter()\n        # Predict here\n        elapsed = 1000 * (perf_counter() - t0)\n        log.info(\"Model prediction time: %d ms.\", elapsed)\n        return None\n</code></pre>"},{"location":"modules/#mydi.camel_to_snake","title":"<code>camel_to_snake(name)</code>","text":"<p>Convert CamelCase to snake_case using pre-compiled regex for efficiency.</p> Source code in <code>src/dhti_elixir_base/mydi.py</code> <pre><code>def camel_to_snake(name: str) -&gt; str:\n    \"\"\"Convert CamelCase to snake_case using pre-compiled regex for efficiency.\"\"\"\n    return _CAMEL_TO_SNAKE_PATTERN.sub(\"_\", name).lower()\n</code></pre>"},{"location":"modules/#server.BaseServer","title":"<code>BaseServer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A server class to load the model and tokenizer</p> Source code in <code>src/dhti_elixir_base/server.py</code> <pre><code>class BaseServer(ABC):\n    \"\"\"A server class to load the model and tokenizer\"\"\"\n\n    class RequestSchema(BaseModel):\n        text: str = Field()\n        labels: list = Field()\n        required: list = Field()\n\n    class ResponseSchema(BaseModel):\n        text: str = Field()\n\n    request_schema = RequestSchema\n    response_schema = ResponseSchema\n\n    def __init__(\n        self, model: BaseDhtiModel, request_schema: Any = None, response_schema: Any = None\n    ) -&gt; None:\n        self.model = model\n        if request_schema is not None:\n            self.request_schema = request_schema\n        if response_schema is not None:\n            self.response_schema = response_schema\n\n    @property\n    def name(self):\n        return camel_to_snake(self.__class__.__name__)\n\n    def health_check(self) -&gt; Any:\n        \"\"\"Health check endpoint\"\"\"\n        self.model.load()\n        return {\"status\": \"ok\"}\n\n    def get_schema(self) -&gt; Any:\n        \"\"\"Get the request schema\"\"\"\n        return self.request_schema\n\n    def predict(self, input: Any, **kwargs) -&gt; Any:\n        _input = self.request_schema(**input)  # type: ignore\n        _result = self.model.predict(_input, **kwargs)\n        result = self.response_schema(**_result)  # type: ignore\n        return result\n</code></pre>"},{"location":"modules/#server.BaseServer.get_schema","title":"<code>get_schema()</code>","text":"<p>Get the request schema</p> Source code in <code>src/dhti_elixir_base/server.py</code> <pre><code>def get_schema(self) -&gt; Any:\n    \"\"\"Get the request schema\"\"\"\n    return self.request_schema\n</code></pre>"},{"location":"modules/#server.BaseServer.health_check","title":"<code>health_check()</code>","text":"<p>Health check endpoint</p> Source code in <code>src/dhti_elixir_base/server.py</code> <pre><code>def health_check(self) -&gt; Any:\n    \"\"\"Health check endpoint\"\"\"\n    self.model.load()\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"modules/#space.BaseSpace","title":"<code>BaseSpace</code>","text":"<p>               Bases: <code>Agent</code></p> Source code in <code>src/dhti_elixir_base/space.py</code> <pre><code>class BaseSpace(Agent):\n\n    from typing import Optional\n\n    def __init__(self, agent: BaseAgent | None = None, *args, **kwargs):\n        if agent:\n            self.agent = agent.get_agent()\n            super().__init__(id=agent.name, *args, **kwargs)\n\n    @action\n    def say(self, content: str, current_patient_context: str = \"\"):\n        \"\"\"Search for a patient in the FHIR database.\"\"\"\n        #! TODO: Needs bootstrapping here.\n\n        message = {\n            \"input\": content,\n            \"current_patient_context\": current_patient_context,\n        }\n        response_content = self.agent.invoke(message)\n        self.send(\n            {\n                \"to\": self.current_message()[\"from\"], # type: ignore\n                \"action\": {\n                    \"name\": \"say\",\n                    \"args\": {\n                        \"content\": response_content[\"output\"],\n                    },\n                },\n            }\n        )\n        return True\n</code></pre>"},{"location":"modules/#space.BaseSpace.say","title":"<code>say(content, current_patient_context='')</code>","text":"<p>Search for a patient in the FHIR database.</p> Source code in <code>src/dhti_elixir_base/space.py</code> <pre><code>@action\ndef say(self, content: str, current_patient_context: str = \"\"):\n    \"\"\"Search for a patient in the FHIR database.\"\"\"\n    #! TODO: Needs bootstrapping here.\n\n    message = {\n        \"input\": content,\n        \"current_patient_context\": current_patient_context,\n    }\n    response_content = self.agent.invoke(message)\n    self.send(\n        {\n            \"to\": self.current_message()[\"from\"], # type: ignore\n            \"action\": {\n                \"name\": \"say\",\n                \"args\": {\n                    \"content\": response_content[\"output\"],\n                },\n            },\n        }\n    )\n    return True\n</code></pre>"},{"location":"modules/#cds_hook.card.CDSHookCard","title":"<code>CDSHookCard</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>CDS Hook Card Model</p> Source code in <code>src/dhti_elixir_base/cds_hook/card.py</code> <pre><code>class CDSHookCard(BaseModel):\n    \"\"\"CDS Hook Card Model\"\"\"\n    summary: str\n    detail: str | None = None\n    indicator: Literal[\"info\", \"warning\", \"hard-stop\"] | None = None\n    source: CDSHookCardSource | None = None\n    links: list[CDSHookCardLink] | None = None\n</code></pre>"},{"location":"modules/#cds_hook.card.CDSHookCardLink","title":"<code>CDSHookCardLink</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Link associated with the CDS Hook Card</p> Source code in <code>src/dhti_elixir_base/cds_hook/card.py</code> <pre><code>class CDSHookCardLink(BaseModel):\n    \"\"\"Link associated with the CDS Hook Card\"\"\"\n    label: str\n    url: str\n</code></pre>"},{"location":"modules/#cds_hook.card.CDSHookCardSource","title":"<code>CDSHookCardSource</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Source of the CDS Hook Card</p> Source code in <code>src/dhti_elixir_base/cds_hook/card.py</code> <pre><code>class CDSHookCardSource(BaseModel):\n    \"\"\"Source of the CDS Hook Card\"\"\"\n    label: str\n    url: str | None = None\n    icon: str | None = None\n</code></pre>"},{"location":"modules/#cds_hook.generate_cards.add_card","title":"<code>add_card(output, cards=None)</code>","text":"<p>Add a CDSHookCard to the output list.</p> Source code in <code>src/dhti_elixir_base/cds_hook/generate_cards.py</code> <pre><code>def add_card(output: str | CDSHookCard, cards: list | None = None) -&gt; dict:\n    \"\"\"Add a CDSHookCard to the output list.\"\"\"\n    if cards is None:\n        cards = []\n    if isinstance(output, CDSHookCard):\n        cards.append(output)\n    elif isinstance(output, str):\n        cards.append(CDSHookCard(summary=output))\n    else:\n        raise ValueError(\"Output must be a string or CDSHookCard\")\n    return {\"cards\": cards}\n</code></pre>"},{"location":"modules/#cds_hook.generate_cards.get_card","title":"<code>get_card(output)</code>","text":"<p>Get a CDSHookCard as a dictionary.</p> Source code in <code>src/dhti_elixir_base/cds_hook/generate_cards.py</code> <pre><code>def get_card(output: str | CDSHookCard) -&gt; dict:\n    \"\"\"Get a CDSHookCard as a dictionary.\"\"\"\n    if isinstance(output, CDSHookCard):\n        return output.model_dump()\n    elif isinstance(output, str):\n        return {\"cards\": [CDSHookCard(summary=output).model_dump()]}\n    else:\n        raise ValueError(\"Output must be a string or CDSHookCard\")\n</code></pre>"},{"location":"modules/#cds_hook.request.CDSHookRequest","title":"<code>CDSHookRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>CDS Hook Request Model</p> Source code in <code>src/dhti_elixir_base/cds_hook/request.py</code> <pre><code>class CDSHookRequest(BaseModel):\n    \"\"\"CDS Hook Request Model\"\"\"\n    hookInstance: str | None = None\n    fhirServer: HttpUrl | None = None\n    fhirAuthorization: Any | None = None\n    hook: str | None = None  # e.g., \"patient-view\", \"order-select\", etc.\n    context: Any | None = None\n    prefetch: Any | None = None\n</code></pre>"},{"location":"modules/#cds_hook.service.CDSHookService","title":"<code>CDSHookService</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>CDS Hook Service Model</p> Source code in <code>src/dhti_elixir_base/cds_hook/service.py</code> <pre><code>class CDSHookService(BaseModel):\n    \"\"\"CDS Hook Service Model\"\"\"\n    hook: str\n    name: str\n    description: str | None = None\n    id: str\n    prefetch: dict | None = None\n</code></pre>"},{"location":"modules/#cds_hook.service.CDSHookServicesResponse","title":"<code>CDSHookServicesResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model containing a list of CDS Hook Services</p> Source code in <code>src/dhti_elixir_base/cds_hook/service.py</code> <pre><code>class CDSHookServicesResponse(BaseModel):\n    \"\"\"Response model containing a list of CDS Hook Services\"\"\"\n    services: list[CDSHookService]\n</code></pre>"},{"location":"modules/#fhir.fhir_search.DhtiFhirSearch","title":"<code>DhtiFhirSearch</code>","text":"Source code in <code>src/dhti_elixir_base/fhir/fhir_search.py</code> <pre><code>class DhtiFhirSearch:\n\n    def __init__(self):\n        self.fhir_base_url = get_di(\"fhir_base_url\") or \"http://hapi.fhir.org/baseR4\"\n        self.page_size = get_di(\"fhir_page_size\") or 10\n        self.requests_kwargs = get_di(\"fhir_requests_kwargs\") or {}\n        self.access_token = get_di(\"fhir_access_token\") or \"\"\n\n    def get_patient_id(self, input_data):\n        # patient_id is the value for key patientId or patient_id or id or PatientId, patientID, PatientID etc\n        try:\n            patient_id = (\n                input_data.get(\"patientId\")\n                or input_data.get(\"patient_id\")\n                or input_data.get(\"id\")\n                or input_data.get(\"PatientId\")\n                or input_data.get(\"patientID\")\n                or input_data.get(\"PatientID\")\n                or input_data.get(\"ID\")\n                or input_data.get(\"Id\")\n                or input_data.get(\"patient\")\n                or input_data.get(\"Patient\")\n                or input_data.get(\"subject\")\n            )\n            return patient_id\n        except AttributeError:\n            return input_data\n\n    def _search_patient_resources(self, resource_type: str, input_data=None, fhirpath=None):\n        \"\"\"Internal helper to search for patient-related resources.\n\n        This method consolidates the common search logic for patient resources,\n        reducing code duplication and improving maintainability.\n\n        Args:\n            resource_type (str): FHIR resource type (e.g., \"Condition\", \"Observation\").\n            input_data (dict or str): Input containing patient ID or the patient ID itself.\n            fhirpath (str, optional): FHIRPath expression to apply to the results.\n\n        Returns:\n            dict: Search results from the FHIR server.\n        \"\"\"\n        if input_data is None:\n            input_data = {}\n        patient_id = self.get_patient_id(input_data)\n        if not patient_id:\n            raise ValueError(\"Patient ID is required.\")\n        headers = {\"Content-Type\": \"application/fhir+json\"}\n        search_url = f\"{self.fhir_base_url}/{resource_type}\"\n        search_parameters = {\"patient\": patient_id, \"_count\": self.page_size}\n        r = requests.get(\n            search_url,\n            params=search_parameters,\n            headers=headers,\n            **self.requests_kwargs,\n        )\n        r.raise_for_status()\n        data = r.json()\n        return evaluate(data, fhirpath, {}) if fhirpath else data\n\n    def get_everything_for_patient(self, input_data=None, fhirpath=None):\n        \"\"\"Fetch all resources related to a specific patient using the $everything operation.\n        Args:\n            input_data (dict or str): Input containing patient ID or the patient ID itself.\n            fhirpath (str, optional): FHIRPath expression to apply to the results.\n        Returns:\n            dict: Combined resources related to the patient.\n        \"\"\"\n        if input_data is None:\n            input_data = {}\n        patient_id = self.get_patient_id(input_data)\n        if not patient_id:\n            raise ValueError(\"Patient ID is required.\")\n        headers = {\n            \"Authorization\": f\"Basic {self.access_token}\",\n            \"Content-Type\": \"application/fhir+json\",\n            \"Accept\": \"application/fhir+json\",\n        }\n        everything_url = f\"{self.fhir_base_url}/Patient/{patient_id}/$everything\"\n        r = requests.get(everything_url, headers=headers, **self.requests_kwargs)\n        r.raise_for_status()\n        data = r.json()\n        return evaluate(data, fhirpath, {}) if fhirpath else data\n\n    def get_conditions_for_patient(self, input_data=None, fhirpath=None):\n        \"\"\"Fetch all Condition resources related to a specific patient.\n        Args:\n            input_data (dict or str): Input containing patient ID or the patient ID itself.\n            fhirpath (str, optional): FHIRPath expression to apply to the results.\n        Returns:\n            dict: Combined Condition resources related to the patient.\n        \"\"\"\n        return self._search_patient_resources(\"Condition\", input_data, fhirpath)\n\n    def get_observations_for_patient(self, input_data=None, fhirpath=None):\n        \"\"\"Fetch all Observation resources related to a specific patient.\n        Args:\n            input_data (dict or str): Input containing patient ID or the patient ID itself.\n            fhirpath (str, optional): FHIRPath expression to apply to the results.\n        Returns:\n            dict: Combined Observation resources related to the patient.\n        \"\"\"\n        return self._search_patient_resources(\"Observation\", input_data, fhirpath)\n\n    def get_procedures_for_patient(self, input_data=None, fhirpath=None):\n        \"\"\"Fetch all Procedure resources related to a specific patient.\n        Args:\n            input_data (dict or str): Input containing patient ID or the patient ID itself.\n            fhirpath (str, optional): FHIRPath expression to apply to the results.\n        Returns:\n            dict: Combined Procedure resources related to the patient.\n        \"\"\"\n        return self._search_patient_resources(\"Procedure\", input_data, fhirpath)\n\n    def get_medication_requests_for_patient(self, input_data=None, fhirpath=None):\n        \"\"\"Fetch all MedicationRequest resources related to a specific patient.\n        Args:\n            input_data (dict or str): Input containing patient ID or the patient ID itself.\n            fhirpath (str, optional): FHIRPath expression to apply to the results.\n        Returns:\n            dict: Combined MedicationRequest resources related to the patient.\n        \"\"\"\n        return self._search_patient_resources(\"MedicationRequest\", input_data, fhirpath)\n\n    def get_allergy_intolerances_for_patient(self, input_data=None, fhirpath=None):\n        \"\"\"Fetch all AllergyIntolerance resources related to a specific patient.\n        Args:\n            input_data (dict or str): Input containing patient ID or the patient ID itself.\n            fhirpath (str, optional): FHIRPath expression to apply to the results.\n        Returns:\n            dict: Combined AllergyIntolerance resources related to the patient.\n        \"\"\"\n        return self._search_patient_resources(\"AllergyIntolerance\", input_data, fhirpath)\n\n    def search(self, resource_type=\"Patient\", search_parameters=None, fhirpath=None):\n        \"\"\"Search the FHIR server and return the combined results.\n\n        Args:\n            resource_type (str): FHIR resource type to search (e.g., \"Patient\").\n            search_parameters (dict): Query parameters per FHIR spec; _count is\n                auto-set to the configured page size if absent.\n\n        Returns:\n            dict: Combined search results from the FHIR server.\n        \"\"\"\n        if search_parameters is None:\n            search_parameters = {}\n\n        headers = {\"Content-Type\": \"application/fhir+json\"}\n\n        if \"_count\" not in search_parameters:\n            search_parameters[\"_count\"] = self.page_size\n\n        search_url = f\"{self.fhir_base_url}/{resource_type}\"\n        r = requests.get(\n            search_url,\n            params=search_parameters,\n            headers=headers,\n            **self.requests_kwargs,\n        )\n        r.raise_for_status()\n        data = r.json()\n        return evaluate(data, fhirpath, {}) if fhirpath else data\n</code></pre>"},{"location":"modules/#fhir.fhir_search.DhtiFhirSearch.get_allergy_intolerances_for_patient","title":"<code>get_allergy_intolerances_for_patient(input_data=None, fhirpath=None)</code>","text":"<p>Fetch all AllergyIntolerance resources related to a specific patient. Args:     input_data (dict or str): Input containing patient ID or the patient ID itself.     fhirpath (str, optional): FHIRPath expression to apply to the results. Returns:     dict: Combined AllergyIntolerance resources related to the patient.</p> Source code in <code>src/dhti_elixir_base/fhir/fhir_search.py</code> <pre><code>def get_allergy_intolerances_for_patient(self, input_data=None, fhirpath=None):\n    \"\"\"Fetch all AllergyIntolerance resources related to a specific patient.\n    Args:\n        input_data (dict or str): Input containing patient ID or the patient ID itself.\n        fhirpath (str, optional): FHIRPath expression to apply to the results.\n    Returns:\n        dict: Combined AllergyIntolerance resources related to the patient.\n    \"\"\"\n    return self._search_patient_resources(\"AllergyIntolerance\", input_data, fhirpath)\n</code></pre>"},{"location":"modules/#fhir.fhir_search.DhtiFhirSearch.get_conditions_for_patient","title":"<code>get_conditions_for_patient(input_data=None, fhirpath=None)</code>","text":"<p>Fetch all Condition resources related to a specific patient. Args:     input_data (dict or str): Input containing patient ID or the patient ID itself.     fhirpath (str, optional): FHIRPath expression to apply to the results. Returns:     dict: Combined Condition resources related to the patient.</p> Source code in <code>src/dhti_elixir_base/fhir/fhir_search.py</code> <pre><code>def get_conditions_for_patient(self, input_data=None, fhirpath=None):\n    \"\"\"Fetch all Condition resources related to a specific patient.\n    Args:\n        input_data (dict or str): Input containing patient ID or the patient ID itself.\n        fhirpath (str, optional): FHIRPath expression to apply to the results.\n    Returns:\n        dict: Combined Condition resources related to the patient.\n    \"\"\"\n    return self._search_patient_resources(\"Condition\", input_data, fhirpath)\n</code></pre>"},{"location":"modules/#fhir.fhir_search.DhtiFhirSearch.get_everything_for_patient","title":"<code>get_everything_for_patient(input_data=None, fhirpath=None)</code>","text":"<p>Fetch all resources related to a specific patient using the $everything operation. Args:     input_data (dict or str): Input containing patient ID or the patient ID itself.     fhirpath (str, optional): FHIRPath expression to apply to the results. Returns:     dict: Combined resources related to the patient.</p> Source code in <code>src/dhti_elixir_base/fhir/fhir_search.py</code> <pre><code>def get_everything_for_patient(self, input_data=None, fhirpath=None):\n    \"\"\"Fetch all resources related to a specific patient using the $everything operation.\n    Args:\n        input_data (dict or str): Input containing patient ID or the patient ID itself.\n        fhirpath (str, optional): FHIRPath expression to apply to the results.\n    Returns:\n        dict: Combined resources related to the patient.\n    \"\"\"\n    if input_data is None:\n        input_data = {}\n    patient_id = self.get_patient_id(input_data)\n    if not patient_id:\n        raise ValueError(\"Patient ID is required.\")\n    headers = {\n        \"Authorization\": f\"Basic {self.access_token}\",\n        \"Content-Type\": \"application/fhir+json\",\n        \"Accept\": \"application/fhir+json\",\n    }\n    everything_url = f\"{self.fhir_base_url}/Patient/{patient_id}/$everything\"\n    r = requests.get(everything_url, headers=headers, **self.requests_kwargs)\n    r.raise_for_status()\n    data = r.json()\n    return evaluate(data, fhirpath, {}) if fhirpath else data\n</code></pre>"},{"location":"modules/#fhir.fhir_search.DhtiFhirSearch.get_medication_requests_for_patient","title":"<code>get_medication_requests_for_patient(input_data=None, fhirpath=None)</code>","text":"<p>Fetch all MedicationRequest resources related to a specific patient. Args:     input_data (dict or str): Input containing patient ID or the patient ID itself.     fhirpath (str, optional): FHIRPath expression to apply to the results. Returns:     dict: Combined MedicationRequest resources related to the patient.</p> Source code in <code>src/dhti_elixir_base/fhir/fhir_search.py</code> <pre><code>def get_medication_requests_for_patient(self, input_data=None, fhirpath=None):\n    \"\"\"Fetch all MedicationRequest resources related to a specific patient.\n    Args:\n        input_data (dict or str): Input containing patient ID or the patient ID itself.\n        fhirpath (str, optional): FHIRPath expression to apply to the results.\n    Returns:\n        dict: Combined MedicationRequest resources related to the patient.\n    \"\"\"\n    return self._search_patient_resources(\"MedicationRequest\", input_data, fhirpath)\n</code></pre>"},{"location":"modules/#fhir.fhir_search.DhtiFhirSearch.get_observations_for_patient","title":"<code>get_observations_for_patient(input_data=None, fhirpath=None)</code>","text":"<p>Fetch all Observation resources related to a specific patient. Args:     input_data (dict or str): Input containing patient ID or the patient ID itself.     fhirpath (str, optional): FHIRPath expression to apply to the results. Returns:     dict: Combined Observation resources related to the patient.</p> Source code in <code>src/dhti_elixir_base/fhir/fhir_search.py</code> <pre><code>def get_observations_for_patient(self, input_data=None, fhirpath=None):\n    \"\"\"Fetch all Observation resources related to a specific patient.\n    Args:\n        input_data (dict or str): Input containing patient ID or the patient ID itself.\n        fhirpath (str, optional): FHIRPath expression to apply to the results.\n    Returns:\n        dict: Combined Observation resources related to the patient.\n    \"\"\"\n    return self._search_patient_resources(\"Observation\", input_data, fhirpath)\n</code></pre>"},{"location":"modules/#fhir.fhir_search.DhtiFhirSearch.get_procedures_for_patient","title":"<code>get_procedures_for_patient(input_data=None, fhirpath=None)</code>","text":"<p>Fetch all Procedure resources related to a specific patient. Args:     input_data (dict or str): Input containing patient ID or the patient ID itself.     fhirpath (str, optional): FHIRPath expression to apply to the results. Returns:     dict: Combined Procedure resources related to the patient.</p> Source code in <code>src/dhti_elixir_base/fhir/fhir_search.py</code> <pre><code>def get_procedures_for_patient(self, input_data=None, fhirpath=None):\n    \"\"\"Fetch all Procedure resources related to a specific patient.\n    Args:\n        input_data (dict or str): Input containing patient ID or the patient ID itself.\n        fhirpath (str, optional): FHIRPath expression to apply to the results.\n    Returns:\n        dict: Combined Procedure resources related to the patient.\n    \"\"\"\n    return self._search_patient_resources(\"Procedure\", input_data, fhirpath)\n</code></pre>"},{"location":"modules/#fhir.fhir_search.DhtiFhirSearch.search","title":"<code>search(resource_type='Patient', search_parameters=None, fhirpath=None)</code>","text":"<p>Search the FHIR server and return the combined results.</p> <p>Parameters:</p> Name Type Description Default <code>resource_type</code> <code>str</code> <p>FHIR resource type to search (e.g., \"Patient\").</p> <code>'Patient'</code> <code>search_parameters</code> <code>dict</code> <p>Query parameters per FHIR spec; _count is auto-set to the configured page size if absent.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Combined search results from the FHIR server.</p> Source code in <code>src/dhti_elixir_base/fhir/fhir_search.py</code> <pre><code>def search(self, resource_type=\"Patient\", search_parameters=None, fhirpath=None):\n    \"\"\"Search the FHIR server and return the combined results.\n\n    Args:\n        resource_type (str): FHIR resource type to search (e.g., \"Patient\").\n        search_parameters (dict): Query parameters per FHIR spec; _count is\n            auto-set to the configured page size if absent.\n\n    Returns:\n        dict: Combined search results from the FHIR server.\n    \"\"\"\n    if search_parameters is None:\n        search_parameters = {}\n\n    headers = {\"Content-Type\": \"application/fhir+json\"}\n\n    if \"_count\" not in search_parameters:\n        search_parameters[\"_count\"] = self.page_size\n\n    search_url = f\"{self.fhir_base_url}/{resource_type}\"\n    r = requests.get(\n        search_url,\n        params=search_parameters,\n        headers=headers,\n        **self.requests_kwargs,\n    )\n    r.raise_for_status()\n    data = r.json()\n    return evaluate(data, fhirpath, {}) if fhirpath else data\n</code></pre>"},{"location":"modules/#fhir.smart_on_fhir.SmartOnFhirSearch","title":"<code>SmartOnFhirSearch</code>","text":"<p>SMART-on-FHIR backed search helper mirroring DhtiFhirSearch API.</p> <p>Uses fhirclient's resource model search pattern, e.g.:</p> <pre><code>    settings = { 'app_id': 'my_web_app', 'api_base': 'https://r4.smarthealthit.org' }\n    smart = client.FHIRClient(settings=settings)\n    patient = Patient.read('&lt;id&gt;', smart.server)\n</code></pre> <p>Each method returns raw JSON like DhtiFhirSearch and optionally applies a FHIRPath expression via fhirpathpy.evaluate.</p> Source code in <code>src/dhti_elixir_base/fhir/smart_on_fhir.py</code> <pre><code>class SmartOnFhirSearch:\n    \"\"\"SMART-on-FHIR backed search helper mirroring DhtiFhirSearch API.\n\n    Uses fhirclient's resource model search pattern, e.g.:\n\n            settings = { 'app_id': 'my_web_app', 'api_base': 'https://r4.smarthealthit.org' }\n            smart = client.FHIRClient(settings=settings)\n            patient = Patient.read('&lt;id&gt;', smart.server)\n\n    Each method returns raw JSON like DhtiFhirSearch and optionally applies a\n    FHIRPath expression via fhirpathpy.evaluate.\n    \"\"\"\n\n    def __init__(self):\n        app_id = get_di(\"fhir_app_id\") or \"my_web_app\"\n        base_url = get_di(\"fhir_base_url\") or \"http://hapi.fhir.org/baseR4\"\n        token = get_di(\"fhir_access_token\") or \"\"\n        settings = {\n            \"app_id\": app_id,\n            \"api_base\": base_url,\n        }\n        if token:\n            settings[\"access_token\"] = token\n\n        self.smart = client.FHIRClient(settings=settings)\n        self.fhir_base_url = base_url\n        self.page_size = get_di(\"fhir_page_size\") or 10\n        self.requests_kwargs = get_di(\"fhir_requests_kwargs\") or {}\n        self.access_token = token\n        # OAuth settings (optional)\n        self.oauth_token_url = (\n            get_di(\"fhir_oauth_token_url\") or get_di(\"oauth_token_url\") or None\n        )\n        self.oauth_client_id = (\n            get_di(\"fhir_oauth_client_id\") or get_di(\"oauth_client_id\") or None\n        )\n        self.oauth_client_secret = (\n            get_di(\"fhir_oauth_client_secret\") or get_di(\"oauth_client_secret\") or None\n        )\n        self.oauth_scope = get_di(\"fhir_oauth_scope\") or get_di(\"oauth_scope\") or None\n        self.oauth_requests_kwargs = get_di(\"fhir_oauth_requests_kwargs\") or {}\n        self._token_expires_at = 0  # epoch seconds\n        # Ensure any provided token is applied to the fhirclient session\n        self._apply_auth_to_server()\n\n    # ------------------------ utils ------------------------\n    def _headers(self) -&gt; dict:\n        headers = {\n            \"Content-Type\": \"application/fhir+json\",\n            \"Accept\": \"application/fhir+json\",\n        }\n        if self.access_token and self.access_token.strip():\n            headers[\"Authorization\"] = f\"Bearer {self.access_token}\"\n        return headers\n\n    def _apply_auth_to_server(self) -&gt; None:\n        \"\"\"Apply Authorization header to the fhirclient server session if possible.\"\"\"\n        try:\n            server = getattr(self.smart, \"server\", None)\n            session = getattr(server, \"session\", None)\n            if session is not None and self.access_token:\n                session.headers[\"Authorization\"] = f\"Bearer {self.access_token}\"\n        except Exception:\n            pass\n\n    def _fetch_token_client_credentials(self) -&gt; None:\n        \"\"\"Fetch OAuth token using client_credentials flow if configured.\"\"\"\n        if not (\n            self.oauth_token_url and self.oauth_client_id and self.oauth_client_secret\n        ):\n            return\n        data = {\"grant_type\": \"client_credentials\"}\n        if self.oauth_scope:\n            data[\"scope\"] = self.oauth_scope\n        # Use HTTP Basic auth; many servers also accept in-body client credentials\n        auth = (self.oauth_client_id, self.oauth_client_secret)\n        r = requests.post(\n            self.oauth_token_url,\n            data=data,\n            auth=auth,\n            headers={\"Accept\": \"application/json\"},\n            **self.oauth_requests_kwargs,\n        )\n        r.raise_for_status()\n        payload = r.json() or {}\n        token = payload.get(\"access_token\")\n        token_type = payload.get(\"token_type\", \"Bearer\")\n        expires_in = payload.get(\"expires_in\", 0)\n        if token:\n            self.access_token = token if token_type.lower() == \"bearer\" else token\n            # Set a small safety margin of 30 seconds\n            import time\n\n            self._token_expires_at = (\n                int(time.time()) + int(expires_in) - 30 if expires_in else 0\n            )\n            self._apply_auth_to_server()\n\n    def _ensure_token(self) -&gt; None:\n        \"\"\"Ensure a valid access token is available and applied.\"\"\"\n        # If we already have a token and no known expiry, assume valid\n        if self.access_token and self._token_expires_at == 0:\n            self._apply_auth_to_server()\n            return\n        # If expired or missing, try to fetch\n        import time\n\n        now = int(time.time())\n        if not self.access_token or (\n            self._token_expires_at and now &gt;= self._token_expires_at\n        ):\n            self._fetch_token_client_credentials()\n            self._apply_auth_to_server()\n\n    def _model_class(self, resource_type: str):\n        \"\"\"Resolve a fhirclient model class for a given resource type name.\n\n        Returns None if the module/class cannot be resolved.\n        \"\"\"\n        try:\n            module_name = resource_type.lower()\n            mod = importlib.import_module(f\"fhirclient.models.{module_name}\")\n            return getattr(mod, resource_type)\n        except Exception:\n            return None\n\n    def get_patient_id(self, input):\n        # Same extraction behavior as DhtiFhirSearch\n        try:\n            patient_id = (\n                input.get(\"patientId\")\n                or input.get(\"patient_id\")\n                or input.get(\"id\")\n                or input.get(\"PatientId\")\n                or input.get(\"patientID\")\n                or input.get(\"PatientID\")\n                or input.get(\"ID\")\n                or input.get(\"Id\")\n                or input.get(\"patient\")\n                or input.get(\"Patient\")\n                or input.get(\"subject\")\n            )\n            return patient_id\n        except AttributeError:\n            return input\n\n    # ---------------------- operations ---------------------\n    def get_everything_for_patient(\n        self, input_data: dict | str | None = None, fhirpath: str | None = None\n    ):\n        \"\"\"Fetch resources related to a patient using $everything operation.\n\n        Returns JSON Bundle like DhtiFhirSearch.\n        \"\"\"\n        if input_data is None:\n            input_data = {}\n        patient_id = self.get_patient_id(input_data)\n        if not patient_id:\n            raise ValueError(\"Patient ID is required.\")\n\n        # Ensure token present for authenticated endpoints\n        self._ensure_token()\n        # Use explicit HTTP for predictable headers and testing\n        path = f\"Patient/{patient_id}/$everything\"\n        url = f\"{self.fhir_base_url}/{path}\"\n        r = requests.get(url, headers=self._headers(), **self.requests_kwargs)\n        r.raise_for_status()\n        data = r.json()\n\n        return evaluate(data, fhirpath, {}) if fhirpath else data\n\n    def get_conditions_for_patient(\n        self, input_data: dict | str | None = None, fhirpath: str | None = None\n    ):\n        if input_data is None:\n            input_data = {}\n        patient_id = self.get_patient_id(input_data)\n        if not patient_id:\n            raise ValueError(\"Patient ID is required.\")\n        self._ensure_token()\n        search = Condition.where(\n            struct={\"patient\": patient_id, \"_count\": self.page_size}\n        )\n        bundle = search.perform(self.smart.server)\n        data = bundle.as_json() if hasattr(bundle, \"as_json\") else bundle\n        return evaluate(data, fhirpath, {}) if fhirpath else data\n\n    def get_observations_for_patient(\n        self, input_data: dict | str | None = None, fhirpath: str | None = None\n    ):\n        if input_data is None:\n            input_data = {}\n        patient_id = self.get_patient_id(input_data)\n        if not patient_id:\n            raise ValueError(\"Patient ID is required.\")\n        self._ensure_token()\n        search = Observation.where(\n            struct={\"patient\": patient_id, \"_count\": self.page_size}\n        )\n        bundle = search.perform(self.smart.server)\n        data = bundle.as_json() if hasattr(bundle, \"as_json\") else bundle\n        return evaluate(data, fhirpath, {}) if fhirpath else data\n\n    def get_procedures_for_patient(\n        self, input_data: dict | str | None = None, fhirpath: str | None = None\n    ):\n        if input_data is None:\n            input_data = {}\n        patient_id = self.get_patient_id(input_data)\n        if not patient_id:\n            raise ValueError(\"Patient ID is required.\")\n        self._ensure_token()\n        search = Procedure.where(\n            struct={\"patient\": patient_id, \"_count\": self.page_size}\n        )\n        bundle = search.perform(self.smart.server)\n        data = bundle.as_json() if hasattr(bundle, \"as_json\") else bundle\n        return evaluate(data, fhirpath, {}) if fhirpath else data\n\n    def get_medication_requests_for_patient(\n        self, input_data: dict | str | None = None, fhirpath: str | None = None\n    ):\n        if input_data is None:\n            input_data = {}\n        patient_id = self.get_patient_id(input_data)\n        if not patient_id:\n            raise ValueError(\"Patient ID is required.\")\n        self._ensure_token()\n        search = MedicationRequest.where(\n            struct={\"patient\": patient_id, \"_count\": self.page_size}\n        )\n        bundle = search.perform(self.smart.server)\n        data = bundle.as_json() if hasattr(bundle, \"as_json\") else bundle\n        return evaluate(data, fhirpath, {}) if fhirpath else data\n\n    def get_allergy_intolerances_for_patient(\n        self, input_data: dict | str | None = None, fhirpath: str | None = None\n    ):\n        if input_data is None:\n            input_data = {}\n        patient_id = self.get_patient_id(input_data)\n        if not patient_id:\n            raise ValueError(\"Patient ID is required.\")\n        self._ensure_token()\n        search = AllergyIntolerance.where(\n            struct={\"patient\": patient_id, \"_count\": self.page_size}\n        )\n        bundle = search.perform(self.smart.server)\n        data = bundle.as_json() if hasattr(bundle, \"as_json\") else bundle\n        return evaluate(data, fhirpath, {}) if fhirpath else data\n\n    def search(\n        self,\n        resource_type: str = \"Patient\",\n        search_parameters: dict | None = None,\n        fhirpath: str | None = None,\n    ):\n        \"\"\"Generic search for any resource type.\n\n        Tries to resolve the appropriate fhirclient model class and perform a\n        model-based search; if not possible, falls back to an HTTP GET.\n        \"\"\"\n        params = dict(search_parameters or {})\n        if \"_count\" not in params:\n            params[\"_count\"] = self.page_size\n\n        self._ensure_token()\n        cls = self._model_class(resource_type)\n        data = None\n        if cls is not None and hasattr(cls, \"where\"):\n            try:\n                bundle = cls.where(struct=params).perform(self.smart.server)\n                data = bundle.as_json() if hasattr(bundle, \"as_json\") else bundle\n            except Exception:\n                data = None\n\n        if data is None:\n            # Fallback to HTTP (works for unknown/extension resource types)\n            url = f\"{self.fhir_base_url}/{resource_type}\"\n            r = requests.get(\n                url, params=params, headers=self._headers(), **self.requests_kwargs\n            )\n            r.raise_for_status()\n            data = r.json()\n\n        return evaluate(data, fhirpath, {}) if fhirpath else data\n</code></pre>"},{"location":"modules/#fhir.smart_on_fhir.SmartOnFhirSearch.get_everything_for_patient","title":"<code>get_everything_for_patient(input_data=None, fhirpath=None)</code>","text":"<p>Fetch resources related to a patient using $everything operation.</p> <p>Returns JSON Bundle like DhtiFhirSearch.</p> Source code in <code>src/dhti_elixir_base/fhir/smart_on_fhir.py</code> <pre><code>def get_everything_for_patient(\n    self, input_data: dict | str | None = None, fhirpath: str | None = None\n):\n    \"\"\"Fetch resources related to a patient using $everything operation.\n\n    Returns JSON Bundle like DhtiFhirSearch.\n    \"\"\"\n    if input_data is None:\n        input_data = {}\n    patient_id = self.get_patient_id(input_data)\n    if not patient_id:\n        raise ValueError(\"Patient ID is required.\")\n\n    # Ensure token present for authenticated endpoints\n    self._ensure_token()\n    # Use explicit HTTP for predictable headers and testing\n    path = f\"Patient/{patient_id}/$everything\"\n    url = f\"{self.fhir_base_url}/{path}\"\n    r = requests.get(url, headers=self._headers(), **self.requests_kwargs)\n    r.raise_for_status()\n    data = r.json()\n\n    return evaluate(data, fhirpath, {}) if fhirpath else data\n</code></pre>"},{"location":"modules/#fhir.smart_on_fhir.SmartOnFhirSearch.search","title":"<code>search(resource_type='Patient', search_parameters=None, fhirpath=None)</code>","text":"<p>Generic search for any resource type.</p> <p>Tries to resolve the appropriate fhirclient model class and perform a model-based search; if not possible, falls back to an HTTP GET.</p> Source code in <code>src/dhti_elixir_base/fhir/smart_on_fhir.py</code> <pre><code>def search(\n    self,\n    resource_type: str = \"Patient\",\n    search_parameters: dict | None = None,\n    fhirpath: str | None = None,\n):\n    \"\"\"Generic search for any resource type.\n\n    Tries to resolve the appropriate fhirclient model class and perform a\n    model-based search; if not possible, falls back to an HTTP GET.\n    \"\"\"\n    params = dict(search_parameters or {})\n    if \"_count\" not in params:\n        params[\"_count\"] = self.page_size\n\n    self._ensure_token()\n    cls = self._model_class(resource_type)\n    data = None\n    if cls is not None and hasattr(cls, \"where\"):\n        try:\n            bundle = cls.where(struct=params).perform(self.smart.server)\n            data = bundle.as_json() if hasattr(bundle, \"as_json\") else bundle\n        except Exception:\n            data = None\n\n    if data is None:\n        # Fallback to HTTP (works for unknown/extension resource types)\n        url = f\"{self.fhir_base_url}/{resource_type}\"\n        r = requests.get(\n            url, params=params, headers=self._headers(), **self.requests_kwargs\n        )\n        r.raise_for_status()\n        data = r.json()\n\n    return evaluate(data, fhirpath, {}) if fhirpath else data\n</code></pre>"}]}